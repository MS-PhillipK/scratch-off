<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>El's Scratch to Reveal</title>
  <style>
    :root {
      --bg: #0b1220;
      --fg: #e6edf3;
      --muted: #9fb0c3;
      --accent: #5ecba1;
      --card: #141b2b;
      --scratch: #aeb8c3;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--fg);
      background:
        radial-gradient(1200px 800px at 20% -10%, #1a2440 0, transparent 60%),
        radial-gradient(900px 600px at 120% 10%, #101935 0, transparent 60%),
        var(--bg);
      display: grid; place-items: center;
    }
    .wrap { width: min(620px, 92vw); }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.04), transparent), var(--card);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 20px;
      padding: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    h1 { margin: 0 0 8px; font-size: 24px; letter-spacing: 0.2px; }
    p.lede { margin: 0 0 14px; color: var(--muted); }

    .scratch-area {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9; /* responsive area */
      border-radius: 16px;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none; /* capture touches */
      background: #0f172a;
      border: 1px solid rgba(255,255,255,0.08);
    }

    .content {
      position: absolute; inset: 0;
      display: grid; place-items: center;
      text-align: center;
      padding: 16px;
    }
    .content .code {
      font-weight: 800;
      font-size: clamp(22px, 5.2vw, 40px);
      letter-spacing: 1.2px;
      background: linear-gradient(180deg, #fff, #c5ffe3 60%, #cafff0);
      color: transparent;
      -webkit-background-clip: text; background-clip: text;
      filter: drop-shadow(0 1px 0 rgba(0,0,0,0.2));
    }
    .content .label { color: var(--muted); margin-bottom: 8px; font-size: clamp(12px, 2.2vw, 14px); }

    canvas#cover {
      position: absolute; inset: 0; width: 100%; height: 100%;
      background:
        repeating-linear-gradient(135deg,
          var(--scratch) 0 12px,
          #c9d2db 12px 24px);
      cursor: grab;
    }

    .actions { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 14px; }
    button, a.btn {
      appearance: none; border: 0; border-radius: 10px; padding: 10px 14px;
      background: linear-gradient(180deg, #6ee7bf, #35c187);
      color: #0a0f17; font-weight: 700; cursor: pointer;
      box-shadow: 0 6px 18px rgba(53,193,135,0.35);
    }
    .ghost { background: transparent; color: var(--fg); border: 1px solid rgba(255,255,255,0.18); box-shadow: none; }
    .muted { background: #2a344b; color: #d9e3ee; box-shadow: none; }
    .tiny { font-size: 12px; color: var(--muted); margin-top: 10px; }
    .notice { margin-top: 12px; color: var(--muted); font-size: 13px; }
    .hidden { display: none !important; }

    .chat-img {
      max-width: min(90%, 520px);
      width: 100%;
      height: auto;
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,.35);
      margin-bottom: 10px;
      border: 1px solid rgba(255,255,255,.1);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>El Settle - Scratch to reveal your code</h1>
      <p class="lede">Use your mouse or finger to scratch the surface.</p>

      <div class="scratch-area" id="scratch-area">
        <!-- Revealed content underneath the canvas cover -->
        <div class="content" aria-live="polite">
          <div>
            <img class="chat-img" alt="message preview" src=\"assets/teams-message.png\">
            <div class="label">El - Your GitHub Shop Code is</div>
            <div class="code" id="secret-code">G1WHP2XRHP</div>
            <div class="notice" id="copied" role="status" aria-hidden="true">Copied!</div>
          </div>
        </div>
        <canvas id="cover" aria-label="Scratch cover"></canvas>
      </div>

      <div class="actions">
        <button id="reveal">Reveal</button>
        <button id="reset" class="ghost">Reset</button>
        <button id="copy" class="muted" title="Copy the revealed code">Copy code</button>
        <button id="share" class="ghost" title="Share link with this code prefilled">Share</button>
      </div>
      <div class="tiny">Tip: You can set the code via URL like <code>?code=HELLO-2025</code>. Emojis and spaces are supported.</div>
    </div>
  </div>

  <script>
    // ---- Config & helpers ---------------------------------------------------
    const qs = new URLSearchParams(location.search);
    const codeEl = document.getElementById('secret-code');
    const defaultCode = codeEl.textContent.trim();
    const urlCode = (qs.get('code') || '').trim();
    if (urlCode) codeEl.textContent = decodeURIComponent(urlCode);

    const area = document.getElementById('scratch-area');
    const canvas = document.getElementById('cover');
    const ctx = canvas.getContext('2d');

    const DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    let drawing = false;
    let cleared = false;
    let last = null;
    let totalPixels, clearedPixels;

    function sizeCanvas() {
      const { width, height } = area.getBoundingClientRect();
      canvas.width = Math.floor(width * DPR);
      canvas.height = Math.floor(height * DPR);
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      // Fill the cover paint layer (solid); CSS provides visual pattern beneath
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = '#b9c3cd';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // Prepare for erasing
      ctx.globalCompositeOperation = 'destination-out';
      cleared = false;
      last = null;
      computeTotals();
    }

    function computeTotals() {
      // Cache pixel count for coverage checks
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      totalPixels = img.data.length / 4; // rgba per pixel
      clearedPixels = 0;
    }

    function dist(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y; return Math.hypot(dx, dy);
    }

    function posFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      let x, y;
      if (e.touches && e.touches[0]) { x = e.touches[0].clientX; y = e.touches[0].clientY; }
      else { x = e.clientX; y = e.clientY; }
      return { x: (x - rect.left) * DPR, y: (y - rect.top) * DPR };
    }

    function scratchAt(p, radius = 26 * DPR) {
      ctx.beginPath();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = radius * 2;
      if (last) {
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
      ctx.fill();
      last = p;
    }

    function coverageEstimate() {
      // Sample the alpha channel sparsely for performance
      const sampleStep = 8; // higher = faster, less precise
      const { width, height } = canvas;
      let clearedCount = 0, totalCount = 0;
      const data = ctx.getImageData(0, 0, width, height).data;
      for (let y = 0; y < height; y += sampleStep) {
        for (let x = 0; x < width; x += sampleStep) {
          const idx = ((y * width) + x) * 4 + 3; // alpha channel
          if (data[idx] === 0) clearedCount++;
          totalCount++;
        }
      }
      return clearedCount / totalCount;
    }

    function autoRevealIfDone() {
      if (cleared) return;
      const ratio = coverageEstimate();
      if (ratio > 0.6) reveal();
    }

    function reveal() {
      cleared = true;
      ctx.globalCompositeOperation = 'destination-out';
      ctx.fillStyle = 'rgba(0,0,0,1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      canvas.classList.add('hidden');
    }

    function reset() {
      canvas.classList.remove('hidden');
      sizeCanvas();
    }

    // ---- Events -------------------------------------------------------------
    function start(e) { drawing = true; last = posFromEvent(e); scratchAt(last); e.preventDefault(); }
    function move(e) { if (!drawing) return; scratchAt(posFromEvent(e)); autoRevealIfDone(); e.preventDefault(); }
    function end() { drawing = false; last = null; autoRevealIfDone(); }

    canvas.addEventListener('mousedown', start);
    canvas.addEventListener('mousemove', move);
    window.addEventListener('mouseup', end);

    canvas.addEventListener('touchstart', start, { passive: false });
    canvas.addEventListener('touchmove', move, { passive: false });
    window.addEventListener('touchend', end);

    window.addEventListener('resize', sizeCanvas);

    // Controls
    document.getElementById('reveal').addEventListener('click', reveal);
    document.getElementById('reset').addEventListener('click', reset);
    document.getElementById('copy').addEventListener('click', async () => {
      const text = codeEl.textContent.trim();
      try { await navigator.clipboard.writeText(text); flashCopied(); }
      catch { fallbackCopy(text); flashCopied(); }
    });

    document.getElementById('share').addEventListener('click', async () => {
      const url = new URL(location.href);
      url.searchParams.set('code', encodeURIComponent(codeEl.textContent.trim()));
      const shareUrl = url.toString();
      try {
        if (navigator.share) {
          await navigator.share({ title: 'Scratch Code', text: 'Here\'s your scratch code', url: shareUrl });
        } else {
          await navigator.clipboard.writeText(shareUrl);
          alert('Sharable link copied to clipboard');
        }
      } catch (e) { /* user cancelled; ignore */ }
    });

    function flashCopied() {
      const el = document.getElementById('copied');
      el.classList.remove('hidden');
      el.textContent = 'Copied!';
      el.setAttribute('aria-hidden', 'false');
      setTimeout(() => { el.classList.add('hidden'); el.setAttribute('aria-hidden', 'true'); }, 1200);
    }

    function fallbackCopy(text) {
      const ta = document.createElement('textarea');
      ta.value = text; document.body.appendChild(ta); ta.select();
      try { document.execCommand('copy'); } finally { document.body.removeChild(ta); }
    }

    // Init
    sizeCanvas();
  </script>
</body>
</html>
